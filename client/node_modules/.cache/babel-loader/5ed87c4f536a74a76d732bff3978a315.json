{"ast":null,"code":"\"use strict\";\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nvar Logger = require('./Logger');\n\nvar JsSIP_C = require('./Constants');\n\nvar DigestAuthentication = require('./DigestAuthentication');\n\nvar Transactions = require('./Transactions');\n\nvar logger = new Logger('RequestSender'); // Default event handlers.\n\nvar EventHandlers = {\n  onRequestTimeout: function onRequestTimeout() {},\n  onTransportError: function onTransportError() {},\n  onReceiveResponse: function onReceiveResponse() {},\n  onAuthenticated: function onAuthenticated() {}\n};\n\nmodule.exports = /*#__PURE__*/function () {\n  function RequestSender(ua, request, eventHandlers) {\n    _classCallCheck(this, RequestSender);\n\n    this._ua = ua;\n    this._eventHandlers = eventHandlers;\n    this._method = request.method;\n    this._request = request;\n    this._auth = null;\n    this._challenged = false;\n    this._staled = false; // Define the undefined handlers.\n\n    for (var handler in EventHandlers) {\n      if (Object.prototype.hasOwnProperty.call(EventHandlers, handler)) {\n        if (!this._eventHandlers[handler]) {\n          this._eventHandlers[handler] = EventHandlers[handler];\n        }\n      }\n    } // If ua is in closing process or even closed just allow sending Bye and ACK.\n\n\n    if (ua.status === ua.C.STATUS_USER_CLOSED && (this._method !== JsSIP_C.BYE || this._method !== JsSIP_C.ACK)) {\n      this._eventHandlers.onTransportError();\n    }\n  }\n  /**\n  * Create the client transaction and send the message.\n  */\n\n\n  _createClass(RequestSender, [{\n    key: \"send\",\n    value: function send() {\n      var _this = this;\n\n      var eventHandlers = {\n        onRequestTimeout: function onRequestTimeout() {\n          _this._eventHandlers.onRequestTimeout();\n        },\n        onTransportError: function onTransportError() {\n          _this._eventHandlers.onTransportError();\n        },\n        onReceiveResponse: function onReceiveResponse(response) {\n          _this._receiveResponse(response);\n        }\n      };\n\n      switch (this._method) {\n        case 'INVITE':\n          this.clientTransaction = new Transactions.InviteClientTransaction(this._ua, this._ua.transport, this._request, eventHandlers);\n          break;\n\n        case 'ACK':\n          this.clientTransaction = new Transactions.AckClientTransaction(this._ua, this._ua.transport, this._request, eventHandlers);\n          break;\n\n        default:\n          this.clientTransaction = new Transactions.NonInviteClientTransaction(this._ua, this._ua.transport, this._request, eventHandlers);\n      } // If authorization JWT is present, use it.\n\n\n      if (this._ua._configuration.authorization_jwt) {\n        this._request.setHeader('Authorization', this._ua._configuration.authorization_jwt);\n      }\n\n      this.clientTransaction.send();\n    }\n    /**\n    * Called from client transaction when receiving a correct response to the request.\n    * Authenticate request if needed or pass the response back to the applicant.\n    */\n\n  }, {\n    key: \"_receiveResponse\",\n    value: function _receiveResponse(response) {\n      var challenge;\n      var authorization_header_name;\n      var status_code = response.status_code;\n      /*\n      * Authentication\n      * Authenticate once. _challenged_ flag used to avoid infinite authentications.\n      */\n\n      if ((status_code === 401 || status_code === 407) && (this._ua.configuration.password !== null || this._ua.configuration.ha1 !== null)) {\n        // Get and parse the appropriate WWW-Authenticate or Proxy-Authenticate header.\n        if (response.status_code === 401) {\n          challenge = response.parseHeader('www-authenticate');\n          authorization_header_name = 'authorization';\n        } else {\n          challenge = response.parseHeader('proxy-authenticate');\n          authorization_header_name = 'proxy-authorization';\n        } // Verify it seems a valid challenge.\n\n\n        if (!challenge) {\n          logger.debug(\"\".concat(response.status_code, \" with wrong or missing challenge, cannot authenticate\"));\n\n          this._eventHandlers.onReceiveResponse(response);\n\n          return;\n        }\n\n        if (!this._challenged || !this._staled && challenge.stale === true) {\n          if (!this._auth) {\n            this._auth = new DigestAuthentication({\n              username: this._ua.configuration.authorization_user,\n              password: this._ua.configuration.password,\n              realm: this._ua.configuration.realm,\n              ha1: this._ua.configuration.ha1\n            });\n          } // Verify that the challenge is really valid.\n\n\n          if (!this._auth.authenticate(this._request, challenge)) {\n            this._eventHandlers.onReceiveResponse(response);\n\n            return;\n          }\n\n          this._challenged = true; // Update ha1 and realm in the UA.\n\n          this._ua.set('realm', this._auth.get('realm'));\n\n          this._ua.set('ha1', this._auth.get('ha1'));\n\n          if (challenge.stale) {\n            this._staled = true;\n          }\n\n          this._request = this._request.clone();\n          this._request.cseq += 1;\n\n          this._request.setHeader('cseq', \"\".concat(this._request.cseq, \" \").concat(this._method));\n\n          this._request.setHeader(authorization_header_name, this._auth.toString());\n\n          this._eventHandlers.onAuthenticated(this._request);\n\n          this.send();\n        } else {\n          this._eventHandlers.onReceiveResponse(response);\n        }\n      } else {\n        this._eventHandlers.onReceiveResponse(response);\n      }\n    }\n  }]);\n\n  return RequestSender;\n}();","map":{"version":3,"sources":["/Users/tuphan/Desktop/gcallstest/client/node_modules/jssip/lib-es5/RequestSender.js"],"names":["_classCallCheck","instance","Constructor","TypeError","_defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","_createClass","protoProps","staticProps","prototype","Logger","require","JsSIP_C","DigestAuthentication","Transactions","logger","EventHandlers","onRequestTimeout","onTransportError","onReceiveResponse","onAuthenticated","module","exports","RequestSender","ua","request","eventHandlers","_ua","_eventHandlers","_method","method","_request","_auth","_challenged","_staled","handler","hasOwnProperty","call","status","C","STATUS_USER_CLOSED","BYE","ACK","value","send","_this","response","_receiveResponse","clientTransaction","InviteClientTransaction","transport","AckClientTransaction","NonInviteClientTransaction","_configuration","authorization_jwt","setHeader","challenge","authorization_header_name","status_code","configuration","password","ha1","parseHeader","debug","concat","stale","username","authorization_user","realm","authenticate","set","get","clone","cseq","toString"],"mappings":"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","sourcesContent":["\"use strict\";\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar Logger = require('./Logger');\n\nvar JsSIP_C = require('./Constants');\n\nvar DigestAuthentication = require('./DigestAuthentication');\n\nvar Transactions = require('./Transactions');\n\nvar logger = new Logger('RequestSender'); // Default event handlers.\n\nvar EventHandlers = {\n  onRequestTimeout: function onRequestTimeout() {},\n  onTransportError: function onTransportError() {},\n  onReceiveResponse: function onReceiveResponse() {},\n  onAuthenticated: function onAuthenticated() {}\n};\n\nmodule.exports = /*#__PURE__*/function () {\n  function RequestSender(ua, request, eventHandlers) {\n    _classCallCheck(this, RequestSender);\n\n    this._ua = ua;\n    this._eventHandlers = eventHandlers;\n    this._method = request.method;\n    this._request = request;\n    this._auth = null;\n    this._challenged = false;\n    this._staled = false; // Define the undefined handlers.\n\n    for (var handler in EventHandlers) {\n      if (Object.prototype.hasOwnProperty.call(EventHandlers, handler)) {\n        if (!this._eventHandlers[handler]) {\n          this._eventHandlers[handler] = EventHandlers[handler];\n        }\n      }\n    } // If ua is in closing process or even closed just allow sending Bye and ACK.\n\n\n    if (ua.status === ua.C.STATUS_USER_CLOSED && (this._method !== JsSIP_C.BYE || this._method !== JsSIP_C.ACK)) {\n      this._eventHandlers.onTransportError();\n    }\n  }\n  /**\n  * Create the client transaction and send the message.\n  */\n\n\n  _createClass(RequestSender, [{\n    key: \"send\",\n    value: function send() {\n      var _this = this;\n\n      var eventHandlers = {\n        onRequestTimeout: function onRequestTimeout() {\n          _this._eventHandlers.onRequestTimeout();\n        },\n        onTransportError: function onTransportError() {\n          _this._eventHandlers.onTransportError();\n        },\n        onReceiveResponse: function onReceiveResponse(response) {\n          _this._receiveResponse(response);\n        }\n      };\n\n      switch (this._method) {\n        case 'INVITE':\n          this.clientTransaction = new Transactions.InviteClientTransaction(this._ua, this._ua.transport, this._request, eventHandlers);\n          break;\n\n        case 'ACK':\n          this.clientTransaction = new Transactions.AckClientTransaction(this._ua, this._ua.transport, this._request, eventHandlers);\n          break;\n\n        default:\n          this.clientTransaction = new Transactions.NonInviteClientTransaction(this._ua, this._ua.transport, this._request, eventHandlers);\n      } // If authorization JWT is present, use it.\n\n\n      if (this._ua._configuration.authorization_jwt) {\n        this._request.setHeader('Authorization', this._ua._configuration.authorization_jwt);\n      }\n\n      this.clientTransaction.send();\n    }\n    /**\n    * Called from client transaction when receiving a correct response to the request.\n    * Authenticate request if needed or pass the response back to the applicant.\n    */\n\n  }, {\n    key: \"_receiveResponse\",\n    value: function _receiveResponse(response) {\n      var challenge;\n      var authorization_header_name;\n      var status_code = response.status_code;\n      /*\n      * Authentication\n      * Authenticate once. _challenged_ flag used to avoid infinite authentications.\n      */\n\n      if ((status_code === 401 || status_code === 407) && (this._ua.configuration.password !== null || this._ua.configuration.ha1 !== null)) {\n        // Get and parse the appropriate WWW-Authenticate or Proxy-Authenticate header.\n        if (response.status_code === 401) {\n          challenge = response.parseHeader('www-authenticate');\n          authorization_header_name = 'authorization';\n        } else {\n          challenge = response.parseHeader('proxy-authenticate');\n          authorization_header_name = 'proxy-authorization';\n        } // Verify it seems a valid challenge.\n\n\n        if (!challenge) {\n          logger.debug(\"\".concat(response.status_code, \" with wrong or missing challenge, cannot authenticate\"));\n\n          this._eventHandlers.onReceiveResponse(response);\n\n          return;\n        }\n\n        if (!this._challenged || !this._staled && challenge.stale === true) {\n          if (!this._auth) {\n            this._auth = new DigestAuthentication({\n              username: this._ua.configuration.authorization_user,\n              password: this._ua.configuration.password,\n              realm: this._ua.configuration.realm,\n              ha1: this._ua.configuration.ha1\n            });\n          } // Verify that the challenge is really valid.\n\n\n          if (!this._auth.authenticate(this._request, challenge)) {\n            this._eventHandlers.onReceiveResponse(response);\n\n            return;\n          }\n\n          this._challenged = true; // Update ha1 and realm in the UA.\n\n          this._ua.set('realm', this._auth.get('realm'));\n\n          this._ua.set('ha1', this._auth.get('ha1'));\n\n          if (challenge.stale) {\n            this._staled = true;\n          }\n\n          this._request = this._request.clone();\n          this._request.cseq += 1;\n\n          this._request.setHeader('cseq', \"\".concat(this._request.cseq, \" \").concat(this._method));\n\n          this._request.setHeader(authorization_header_name, this._auth.toString());\n\n          this._eventHandlers.onAuthenticated(this._request);\n\n          this.send();\n        } else {\n          this._eventHandlers.onReceiveResponse(response);\n        }\n      } else {\n        this._eventHandlers.onReceiveResponse(response);\n      }\n    }\n  }]);\n\n  return RequestSender;\n}();"]},"metadata":{},"sourceType":"script"}