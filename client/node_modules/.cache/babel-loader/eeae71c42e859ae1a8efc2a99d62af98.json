{"ast":null,"code":"var grammar = require('./grammar'); // customized util.format - discards excess arguments and can void middle ones\n\n\nvar formatRegExp = /%[sdv%]/g;\n\nvar format = function (formatStr) {\n  var i = 1;\n  var args = arguments;\n  var len = args.length;\n  return formatStr.replace(formatRegExp, function (x) {\n    if (i >= len) {\n      return x; // missing argument\n    }\n\n    var arg = args[i];\n    i += 1;\n\n    switch (x) {\n      case '%%':\n        return '%';\n\n      case '%s':\n        return String(arg);\n\n      case '%d':\n        return Number(arg);\n\n      case '%v':\n        return '';\n    }\n  }); // NB: we discard excess arguments - they are typically undefined from makeLine\n};\n\nvar makeLine = function (type, obj, location) {\n  var str = obj.format instanceof Function ? obj.format(obj.push ? location : location[obj.name]) : obj.format;\n  var args = [type + '=' + str];\n\n  if (obj.names) {\n    for (var i = 0; i < obj.names.length; i += 1) {\n      var n = obj.names[i];\n\n      if (obj.name) {\n        args.push(location[obj.name][n]);\n      } else {\n        // for mLine and push attributes\n        args.push(location[obj.names[i]]);\n      }\n    }\n  } else {\n    args.push(location[obj.name]);\n  }\n\n  return format.apply(null, args);\n}; // RFC specified order\n// TODO: extend this with all the rest\n\n\nvar defaultOuterOrder = ['v', 'o', 's', 'i', 'u', 'e', 'p', 'c', 'b', 't', 'r', 'z', 'a'];\nvar defaultInnerOrder = ['i', 'c', 'b', 'a'];\n\nmodule.exports = function (session, opts) {\n  opts = opts || {}; // ensure certain properties exist\n\n  if (session.version == null) {\n    session.version = 0; // 'v=0' must be there (only defined version atm)\n  }\n\n  if (session.name == null) {\n    session.name = ' '; // 's= ' must be there if no meaningful name set\n  }\n\n  session.media.forEach(function (mLine) {\n    if (mLine.payloads == null) {\n      mLine.payloads = '';\n    }\n  });\n  var outerOrder = opts.outerOrder || defaultOuterOrder;\n  var innerOrder = opts.innerOrder || defaultInnerOrder;\n  var sdp = []; // loop through outerOrder for matching properties on session\n\n  outerOrder.forEach(function (type) {\n    grammar[type].forEach(function (obj) {\n      if (obj.name in session && session[obj.name] != null) {\n        sdp.push(makeLine(type, obj, session));\n      } else if (obj.push in session && session[obj.push] != null) {\n        session[obj.push].forEach(function (el) {\n          sdp.push(makeLine(type, obj, el));\n        });\n      }\n    });\n  }); // then for each media line, follow the innerOrder\n\n  session.media.forEach(function (mLine) {\n    sdp.push(makeLine('m', grammar.m[0], mLine));\n    innerOrder.forEach(function (type) {\n      grammar[type].forEach(function (obj) {\n        if (obj.name in mLine && mLine[obj.name] != null) {\n          sdp.push(makeLine(type, obj, mLine));\n        } else if (obj.push in mLine && mLine[obj.push] != null) {\n          mLine[obj.push].forEach(function (el) {\n            sdp.push(makeLine(type, obj, el));\n          });\n        }\n      });\n    });\n  });\n  return sdp.join('\\r\\n') + '\\r\\n';\n};","map":{"version":3,"sources":["/Users/tuphan/Desktop/gcallstest/client/node_modules/sdp-transform/lib/writer.js"],"names":["grammar","require","formatRegExp","format","formatStr","i","args","arguments","len","length","replace","x","arg","String","Number","makeLine","type","obj","location","str","Function","push","name","names","n","apply","defaultOuterOrder","defaultInnerOrder","module","exports","session","opts","version","media","forEach","mLine","payloads","outerOrder","innerOrder","sdp","el","m","join"],"mappings":"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","sourcesContent":["var grammar = require('./grammar');\n\n// customized util.format - discards excess arguments and can void middle ones\nvar formatRegExp = /%[sdv%]/g;\nvar format = function (formatStr) {\n  var i = 1;\n  var args = arguments;\n  var len = args.length;\n  return formatStr.replace(formatRegExp, function (x) {\n    if (i >= len) {\n      return x; // missing argument\n    }\n    var arg = args[i];\n    i += 1;\n    switch (x) {\n    case '%%':\n      return '%';\n    case '%s':\n      return String(arg);\n    case '%d':\n      return Number(arg);\n    case '%v':\n      return '';\n    }\n  });\n  // NB: we discard excess arguments - they are typically undefined from makeLine\n};\n\nvar makeLine = function (type, obj, location) {\n  var str = obj.format instanceof Function ?\n    (obj.format(obj.push ? location : location[obj.name])) :\n    obj.format;\n\n  var args = [type + '=' + str];\n  if (obj.names) {\n    for (var i = 0; i < obj.names.length; i += 1) {\n      var n = obj.names[i];\n      if (obj.name) {\n        args.push(location[obj.name][n]);\n      }\n      else { // for mLine and push attributes\n        args.push(location[obj.names[i]]);\n      }\n    }\n  }\n  else {\n    args.push(location[obj.name]);\n  }\n  return format.apply(null, args);\n};\n\n// RFC specified order\n// TODO: extend this with all the rest\nvar defaultOuterOrder = [\n  'v', 'o', 's', 'i',\n  'u', 'e', 'p', 'c',\n  'b', 't', 'r', 'z', 'a'\n];\nvar defaultInnerOrder = ['i', 'c', 'b', 'a'];\n\n\nmodule.exports = function (session, opts) {\n  opts = opts || {};\n  // ensure certain properties exist\n  if (session.version == null) {\n    session.version = 0; // 'v=0' must be there (only defined version atm)\n  }\n  if (session.name == null) {\n    session.name = ' '; // 's= ' must be there if no meaningful name set\n  }\n  session.media.forEach(function (mLine) {\n    if (mLine.payloads == null) {\n      mLine.payloads = '';\n    }\n  });\n\n  var outerOrder = opts.outerOrder || defaultOuterOrder;\n  var innerOrder = opts.innerOrder || defaultInnerOrder;\n  var sdp = [];\n\n  // loop through outerOrder for matching properties on session\n  outerOrder.forEach(function (type) {\n    grammar[type].forEach(function (obj) {\n      if (obj.name in session && session[obj.name] != null) {\n        sdp.push(makeLine(type, obj, session));\n      }\n      else if (obj.push in session && session[obj.push] != null) {\n        session[obj.push].forEach(function (el) {\n          sdp.push(makeLine(type, obj, el));\n        });\n      }\n    });\n  });\n\n  // then for each media line, follow the innerOrder\n  session.media.forEach(function (mLine) {\n    sdp.push(makeLine('m', grammar.m[0], mLine));\n\n    innerOrder.forEach(function (type) {\n      grammar[type].forEach(function (obj) {\n        if (obj.name in mLine && mLine[obj.name] != null) {\n          sdp.push(makeLine(type, obj, mLine));\n        }\n        else if (obj.push in mLine && mLine[obj.push] != null) {\n          mLine[obj.push].forEach(function (el) {\n            sdp.push(makeLine(type, obj, el));\n          });\n        }\n      });\n    });\n  });\n\n  return sdp.join('\\r\\n') + '\\r\\n';\n};\n"]},"metadata":{},"sourceType":"script"}