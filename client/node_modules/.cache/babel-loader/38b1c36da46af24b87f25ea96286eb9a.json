{"ast":null,"code":"\"use strict\";\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) {\n  var it;\n\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n\n      var F = function F() {};\n\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function s() {\n      it = o[Symbol.iterator]();\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nvar Logger = require('./Logger');\n\nvar Grammar = require('./Grammar');\n\nvar SIPMessage = require('./SIPMessage');\n\nvar logger = new Logger('Parser');\n/**\n * Parse SIP Message\n */\n\nexports.parseMessage = function (data, ua) {\n  var message;\n  var bodyStart;\n  var headerEnd = data.indexOf('\\r\\n');\n\n  if (headerEnd === -1) {\n    logger.warn('parseMessage() | no CRLF found, not a SIP message');\n    return;\n  } // Parse first line. Check if it is a Request or a Reply.\n\n\n  var firstLine = data.substring(0, headerEnd);\n  var parsed = Grammar.parse(firstLine, 'Request_Response');\n\n  if (parsed === -1) {\n    logger.warn(\"parseMessage() | error parsing first line of SIP message: \\\"\".concat(firstLine, \"\\\"\"));\n    return;\n  } else if (!parsed.status_code) {\n    message = new SIPMessage.IncomingRequest(ua);\n    message.method = parsed.method;\n    message.ruri = parsed.uri;\n  } else {\n    message = new SIPMessage.IncomingResponse();\n    message.status_code = parsed.status_code;\n    message.reason_phrase = parsed.reason_phrase;\n  }\n\n  message.data = data;\n  var headerStart = headerEnd + 2;\n  /* Loop over every line in data. Detect the end of each header and parse\n  * it or simply add to the headers collection.\n  */\n\n  while (true) {\n    headerEnd = getHeader(data, headerStart); // The SIP message has normally finished.\n\n    if (headerEnd === -2) {\n      bodyStart = headerStart + 2;\n      break;\n    } // Data.indexOf returned -1 due to a malformed message.\n    else if (headerEnd === -1) {\n        logger.warn('parseMessage() | malformed message');\n        return;\n      }\n\n    parsed = parseHeader(message, data, headerStart, headerEnd);\n\n    if (parsed !== true) {\n      logger.warn('parseMessage() |', parsed.error);\n      return;\n    }\n\n    headerStart = headerEnd + 2;\n  }\n  /* RFC3261 18.3.\n   * If there are additional bytes in the transport packet\n   * beyond the end of the body, they MUST be discarded.\n   */\n\n\n  if (message.hasHeader('content-length')) {\n    var contentLength = message.getHeader('content-length');\n    message.body = data.substr(bodyStart, contentLength);\n  } else {\n    message.body = data.substring(bodyStart);\n  }\n\n  return message;\n};\n/**\n * Extract and parse every header of a SIP message.\n */\n\n\nfunction getHeader(data, headerStart) {\n  // 'start' position of the header.\n  var start = headerStart; // 'end' position of the header.\n\n  var end = 0; // 'partial end' position of the header.\n\n  var partialEnd = 0; // End of message.\n\n  if (data.substring(start, start + 2).match(/(^\\r\\n)/)) {\n    return -2;\n  }\n\n  while (end === 0) {\n    // Partial End of Header.\n    partialEnd = data.indexOf('\\r\\n', start); // 'indexOf' returns -1 if the value to be found never occurs.\n\n    if (partialEnd === -1) {\n      return partialEnd;\n    }\n\n    if (!data.substring(partialEnd + 2, partialEnd + 4).match(/(^\\r\\n)/) && data.charAt(partialEnd + 2).match(/(^\\s+)/)) {\n      // Not the end of the message. Continue from the next position.\n      start = partialEnd + 2;\n    } else {\n      end = partialEnd;\n    }\n  }\n\n  return end;\n}\n\nfunction parseHeader(message, data, headerStart, headerEnd) {\n  var parsed;\n  var hcolonIndex = data.indexOf(':', headerStart);\n  var headerName = data.substring(headerStart, hcolonIndex).trim();\n  var headerValue = data.substring(hcolonIndex + 1, headerEnd).trim(); // If header-field is well-known, parse it.\n\n  switch (headerName.toLowerCase()) {\n    case 'via':\n    case 'v':\n      message.addHeader('via', headerValue);\n\n      if (message.getHeaders('via').length === 1) {\n        parsed = message.parseHeader('Via');\n\n        if (parsed) {\n          message.via = parsed;\n          message.via_branch = parsed.branch;\n        }\n      } else {\n        parsed = 0;\n      }\n\n      break;\n\n    case 'from':\n    case 'f':\n      message.setHeader('from', headerValue);\n      parsed = message.parseHeader('from');\n\n      if (parsed) {\n        message.from = parsed;\n        message.from_tag = parsed.getParam('tag');\n      }\n\n      break;\n\n    case 'to':\n    case 't':\n      message.setHeader('to', headerValue);\n      parsed = message.parseHeader('to');\n\n      if (parsed) {\n        message.to = parsed;\n        message.to_tag = parsed.getParam('tag');\n      }\n\n      break;\n\n    case 'record-route':\n      parsed = Grammar.parse(headerValue, 'Record_Route');\n\n      if (parsed === -1) {\n        parsed = undefined;\n      } else {\n        var _iterator = _createForOfIteratorHelper(parsed),\n            _step;\n\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var header = _step.value;\n            message.addHeader('record-route', headerValue.substring(header.possition, header.offset));\n            message.headers['Record-Route'][message.getHeaders('record-route').length - 1].parsed = header.parsed;\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n      }\n\n      break;\n\n    case 'call-id':\n    case 'i':\n      message.setHeader('call-id', headerValue);\n      parsed = message.parseHeader('call-id');\n\n      if (parsed) {\n        message.call_id = headerValue;\n      }\n\n      break;\n\n    case 'contact':\n    case 'm':\n      parsed = Grammar.parse(headerValue, 'Contact');\n\n      if (parsed === -1) {\n        parsed = undefined;\n      } else {\n        var _iterator2 = _createForOfIteratorHelper(parsed),\n            _step2;\n\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var _header = _step2.value;\n            message.addHeader('contact', headerValue.substring(_header.possition, _header.offset));\n            message.headers.Contact[message.getHeaders('contact').length - 1].parsed = _header.parsed;\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n      }\n\n      break;\n\n    case 'content-length':\n    case 'l':\n      message.setHeader('content-length', headerValue);\n      parsed = message.parseHeader('content-length');\n      break;\n\n    case 'content-type':\n    case 'c':\n      message.setHeader('content-type', headerValue);\n      parsed = message.parseHeader('content-type');\n      break;\n\n    case 'cseq':\n      message.setHeader('cseq', headerValue);\n      parsed = message.parseHeader('cseq');\n\n      if (parsed) {\n        message.cseq = parsed.value;\n      }\n\n      if (message instanceof SIPMessage.IncomingResponse) {\n        message.method = parsed.method;\n      }\n\n      break;\n\n    case 'max-forwards':\n      message.setHeader('max-forwards', headerValue);\n      parsed = message.parseHeader('max-forwards');\n      break;\n\n    case 'www-authenticate':\n      message.setHeader('www-authenticate', headerValue);\n      parsed = message.parseHeader('www-authenticate');\n      break;\n\n    case 'proxy-authenticate':\n      message.setHeader('proxy-authenticate', headerValue);\n      parsed = message.parseHeader('proxy-authenticate');\n      break;\n\n    case 'session-expires':\n    case 'x':\n      message.setHeader('session-expires', headerValue);\n      parsed = message.parseHeader('session-expires');\n\n      if (parsed) {\n        message.session_expires = parsed.expires;\n        message.session_expires_refresher = parsed.refresher;\n      }\n\n      break;\n\n    case 'refer-to':\n    case 'r':\n      message.setHeader('refer-to', headerValue);\n      parsed = message.parseHeader('refer-to');\n\n      if (parsed) {\n        message.refer_to = parsed;\n      }\n\n      break;\n\n    case 'replaces':\n      message.setHeader('replaces', headerValue);\n      parsed = message.parseHeader('replaces');\n\n      if (parsed) {\n        message.replaces = parsed;\n      }\n\n      break;\n\n    case 'event':\n    case 'o':\n      message.setHeader('event', headerValue);\n      parsed = message.parseHeader('event');\n\n      if (parsed) {\n        message.event = parsed;\n      }\n\n      break;\n\n    default:\n      // Do not parse this header.\n      message.addHeader(headerName, headerValue);\n      parsed = 0;\n  }\n\n  if (parsed === undefined) {\n    return {\n      error: \"error parsing header \\\"\".concat(headerName, \"\\\"\")\n    };\n  } else {\n    return true;\n  }\n}","map":{"version":3,"sources":["/Users/tuphan/Desktop/gcallstest/client/node_modules/jssip/lib-es5/Parser.js"],"names":["_createForOfIteratorHelper","o","allowArrayLike","it","Symbol","iterator","Array","isArray","_unsupportedIterableToArray","length","i","F","s","n","done","value","e","_e","f","TypeError","normalCompletion","didErr","err","step","next","_e2","minLen","_arrayLikeToArray","Object","prototype","toString","call","slice","constructor","name","from","test","arr","len","arr2","Logger","require","Grammar","SIPMessage","logger","exports","parseMessage","data","ua","message","bodyStart","headerEnd","indexOf","warn","firstLine","substring","parsed","parse","concat","status_code","IncomingRequest","method","ruri","uri","IncomingResponse","reason_phrase","headerStart","getHeader","parseHeader","error","hasHeader","contentLength","body","substr","start","end","partialEnd","match","charAt","hcolonIndex","headerName","trim","headerValue","toLowerCase","addHeader","getHeaders","via","via_branch","branch","setHeader","from_tag","getParam","to","to_tag","undefined","_iterator","_step","header","possition","offset","headers","call_id","_iterator2","_step2","_header","Contact","cseq","session_expires","expires","session_expires_refresher","refresher","refer_to","replaces","event"],"mappings":"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","sourcesContent":["\"use strict\";\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nvar Logger = require('./Logger');\n\nvar Grammar = require('./Grammar');\n\nvar SIPMessage = require('./SIPMessage');\n\nvar logger = new Logger('Parser');\n/**\n * Parse SIP Message\n */\n\nexports.parseMessage = function (data, ua) {\n  var message;\n  var bodyStart;\n  var headerEnd = data.indexOf('\\r\\n');\n\n  if (headerEnd === -1) {\n    logger.warn('parseMessage() | no CRLF found, not a SIP message');\n    return;\n  } // Parse first line. Check if it is a Request or a Reply.\n\n\n  var firstLine = data.substring(0, headerEnd);\n  var parsed = Grammar.parse(firstLine, 'Request_Response');\n\n  if (parsed === -1) {\n    logger.warn(\"parseMessage() | error parsing first line of SIP message: \\\"\".concat(firstLine, \"\\\"\"));\n    return;\n  } else if (!parsed.status_code) {\n    message = new SIPMessage.IncomingRequest(ua);\n    message.method = parsed.method;\n    message.ruri = parsed.uri;\n  } else {\n    message = new SIPMessage.IncomingResponse();\n    message.status_code = parsed.status_code;\n    message.reason_phrase = parsed.reason_phrase;\n  }\n\n  message.data = data;\n  var headerStart = headerEnd + 2;\n  /* Loop over every line in data. Detect the end of each header and parse\n  * it or simply add to the headers collection.\n  */\n\n  while (true) {\n    headerEnd = getHeader(data, headerStart); // The SIP message has normally finished.\n\n    if (headerEnd === -2) {\n      bodyStart = headerStart + 2;\n      break;\n    } // Data.indexOf returned -1 due to a malformed message.\n    else if (headerEnd === -1) {\n        logger.warn('parseMessage() | malformed message');\n        return;\n      }\n\n    parsed = parseHeader(message, data, headerStart, headerEnd);\n\n    if (parsed !== true) {\n      logger.warn('parseMessage() |', parsed.error);\n      return;\n    }\n\n    headerStart = headerEnd + 2;\n  }\n  /* RFC3261 18.3.\n   * If there are additional bytes in the transport packet\n   * beyond the end of the body, they MUST be discarded.\n   */\n\n\n  if (message.hasHeader('content-length')) {\n    var contentLength = message.getHeader('content-length');\n    message.body = data.substr(bodyStart, contentLength);\n  } else {\n    message.body = data.substring(bodyStart);\n  }\n\n  return message;\n};\n/**\n * Extract and parse every header of a SIP message.\n */\n\n\nfunction getHeader(data, headerStart) {\n  // 'start' position of the header.\n  var start = headerStart; // 'end' position of the header.\n\n  var end = 0; // 'partial end' position of the header.\n\n  var partialEnd = 0; // End of message.\n\n  if (data.substring(start, start + 2).match(/(^\\r\\n)/)) {\n    return -2;\n  }\n\n  while (end === 0) {\n    // Partial End of Header.\n    partialEnd = data.indexOf('\\r\\n', start); // 'indexOf' returns -1 if the value to be found never occurs.\n\n    if (partialEnd === -1) {\n      return partialEnd;\n    }\n\n    if (!data.substring(partialEnd + 2, partialEnd + 4).match(/(^\\r\\n)/) && data.charAt(partialEnd + 2).match(/(^\\s+)/)) {\n      // Not the end of the message. Continue from the next position.\n      start = partialEnd + 2;\n    } else {\n      end = partialEnd;\n    }\n  }\n\n  return end;\n}\n\nfunction parseHeader(message, data, headerStart, headerEnd) {\n  var parsed;\n  var hcolonIndex = data.indexOf(':', headerStart);\n  var headerName = data.substring(headerStart, hcolonIndex).trim();\n  var headerValue = data.substring(hcolonIndex + 1, headerEnd).trim(); // If header-field is well-known, parse it.\n\n  switch (headerName.toLowerCase()) {\n    case 'via':\n    case 'v':\n      message.addHeader('via', headerValue);\n\n      if (message.getHeaders('via').length === 1) {\n        parsed = message.parseHeader('Via');\n\n        if (parsed) {\n          message.via = parsed;\n          message.via_branch = parsed.branch;\n        }\n      } else {\n        parsed = 0;\n      }\n\n      break;\n\n    case 'from':\n    case 'f':\n      message.setHeader('from', headerValue);\n      parsed = message.parseHeader('from');\n\n      if (parsed) {\n        message.from = parsed;\n        message.from_tag = parsed.getParam('tag');\n      }\n\n      break;\n\n    case 'to':\n    case 't':\n      message.setHeader('to', headerValue);\n      parsed = message.parseHeader('to');\n\n      if (parsed) {\n        message.to = parsed;\n        message.to_tag = parsed.getParam('tag');\n      }\n\n      break;\n\n    case 'record-route':\n      parsed = Grammar.parse(headerValue, 'Record_Route');\n\n      if (parsed === -1) {\n        parsed = undefined;\n      } else {\n        var _iterator = _createForOfIteratorHelper(parsed),\n            _step;\n\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var header = _step.value;\n            message.addHeader('record-route', headerValue.substring(header.possition, header.offset));\n            message.headers['Record-Route'][message.getHeaders('record-route').length - 1].parsed = header.parsed;\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n      }\n\n      break;\n\n    case 'call-id':\n    case 'i':\n      message.setHeader('call-id', headerValue);\n      parsed = message.parseHeader('call-id');\n\n      if (parsed) {\n        message.call_id = headerValue;\n      }\n\n      break;\n\n    case 'contact':\n    case 'm':\n      parsed = Grammar.parse(headerValue, 'Contact');\n\n      if (parsed === -1) {\n        parsed = undefined;\n      } else {\n        var _iterator2 = _createForOfIteratorHelper(parsed),\n            _step2;\n\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var _header = _step2.value;\n            message.addHeader('contact', headerValue.substring(_header.possition, _header.offset));\n            message.headers.Contact[message.getHeaders('contact').length - 1].parsed = _header.parsed;\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n      }\n\n      break;\n\n    case 'content-length':\n    case 'l':\n      message.setHeader('content-length', headerValue);\n      parsed = message.parseHeader('content-length');\n      break;\n\n    case 'content-type':\n    case 'c':\n      message.setHeader('content-type', headerValue);\n      parsed = message.parseHeader('content-type');\n      break;\n\n    case 'cseq':\n      message.setHeader('cseq', headerValue);\n      parsed = message.parseHeader('cseq');\n\n      if (parsed) {\n        message.cseq = parsed.value;\n      }\n\n      if (message instanceof SIPMessage.IncomingResponse) {\n        message.method = parsed.method;\n      }\n\n      break;\n\n    case 'max-forwards':\n      message.setHeader('max-forwards', headerValue);\n      parsed = message.parseHeader('max-forwards');\n      break;\n\n    case 'www-authenticate':\n      message.setHeader('www-authenticate', headerValue);\n      parsed = message.parseHeader('www-authenticate');\n      break;\n\n    case 'proxy-authenticate':\n      message.setHeader('proxy-authenticate', headerValue);\n      parsed = message.parseHeader('proxy-authenticate');\n      break;\n\n    case 'session-expires':\n    case 'x':\n      message.setHeader('session-expires', headerValue);\n      parsed = message.parseHeader('session-expires');\n\n      if (parsed) {\n        message.session_expires = parsed.expires;\n        message.session_expires_refresher = parsed.refresher;\n      }\n\n      break;\n\n    case 'refer-to':\n    case 'r':\n      message.setHeader('refer-to', headerValue);\n      parsed = message.parseHeader('refer-to');\n\n      if (parsed) {\n        message.refer_to = parsed;\n      }\n\n      break;\n\n    case 'replaces':\n      message.setHeader('replaces', headerValue);\n      parsed = message.parseHeader('replaces');\n\n      if (parsed) {\n        message.replaces = parsed;\n      }\n\n      break;\n\n    case 'event':\n    case 'o':\n      message.setHeader('event', headerValue);\n      parsed = message.parseHeader('event');\n\n      if (parsed) {\n        message.event = parsed;\n      }\n\n      break;\n\n    default:\n      // Do not parse this header.\n      message.addHeader(headerName, headerValue);\n      parsed = 0;\n  }\n\n  if (parsed === undefined) {\n    return {\n      error: \"error parsing header \\\"\".concat(headerName, \"\\\"\")\n    };\n  } else {\n    return true;\n  }\n}"]},"metadata":{},"sourceType":"script"}