{"ast":null,"code":"\"use strict\";\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nvar Logger = require('./Logger');\n\nvar Socket = require('./Socket');\n\nvar JsSIP_C = require('./Constants');\n\nvar logger = new Logger('Transport');\n/**\n * Constants\n */\n\nvar C = {\n  // Transport status.\n  STATUS_CONNECTED: 0,\n  STATUS_CONNECTING: 1,\n  STATUS_DISCONNECTED: 2,\n  // Socket status.\n  SOCKET_STATUS_READY: 0,\n  SOCKET_STATUS_ERROR: 1,\n  // Recovery options.\n  recovery_options: {\n    // minimum interval in seconds between recover attempts.\n    min_interval: JsSIP_C.CONNECTION_RECOVERY_MIN_INTERVAL,\n    // maximum interval in seconds between recover attempts.\n    max_interval: JsSIP_C.CONNECTION_RECOVERY_MAX_INTERVAL\n  }\n};\n/*\n * Manages one or multiple JsSIP.Socket instances.\n * Is reponsible for transport recovery logic among all socket instances.\n *\n * @socket JsSIP::Socket instance\n */\n\nmodule.exports = /*#__PURE__*/function () {\n  function Transport(sockets) {\n    var recovery_options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : C.recovery_options;\n\n    _classCallCheck(this, Transport);\n\n    logger.debug('new()');\n    this.status = C.STATUS_DISCONNECTED; // Current socket.\n\n    this.socket = null; // Socket collection.\n\n    this.sockets = [];\n    this.recovery_options = recovery_options;\n    this.recover_attempts = 0;\n    this.recovery_timer = null;\n    this.close_requested = false; // It seems that TextDecoder is not available in some versions of React-Native.\n    // See https://github.com/versatica/JsSIP/issues/695\n\n    try {\n      this.textDecoder = new TextDecoder('utf8');\n    } catch (error) {\n      logger.warn(\"cannot use TextDecoder: \".concat(error));\n    }\n\n    if (typeof sockets === 'undefined') {\n      throw new TypeError('Invalid argument.' + ' undefined \\'sockets\\' argument');\n    }\n\n    if (!(sockets instanceof Array)) {\n      sockets = [sockets];\n    }\n\n    sockets.forEach(function (socket) {\n      if (!Socket.isSocket(socket.socket)) {\n        throw new TypeError('Invalid argument.' + ' invalid \\'JsSIP.Socket\\' instance');\n      }\n\n      if (socket.weight && !Number(socket.weight)) {\n        throw new TypeError('Invalid argument.' + ' \\'weight\\' attribute is not a number');\n      }\n\n      this.sockets.push({\n        socket: socket.socket,\n        weight: socket.weight || 0,\n        status: C.SOCKET_STATUS_READY\n      });\n    }, this); // Get the socket with higher weight.\n\n    this._getSocket();\n  }\n  /**\n   * Instance Methods\n   */\n\n\n  _createClass(Transport, [{\n    key: \"connect\",\n    value: function connect() {\n      logger.debug('connect()');\n\n      if (this.isConnected()) {\n        logger.debug('Transport is already connected');\n        return;\n      } else if (this.isConnecting()) {\n        logger.debug('Transport is connecting');\n        return;\n      }\n\n      this.close_requested = false;\n      this.status = C.STATUS_CONNECTING;\n      this.onconnecting({\n        socket: this.socket,\n        attempts: this.recover_attempts\n      });\n\n      if (!this.close_requested) {\n        // Bind socket event callbacks.\n        this.socket.onconnect = this._onConnect.bind(this);\n        this.socket.ondisconnect = this._onDisconnect.bind(this);\n        this.socket.ondata = this._onData.bind(this);\n        this.socket.connect();\n      }\n\n      return;\n    }\n  }, {\n    key: \"disconnect\",\n    value: function disconnect() {\n      logger.debug('close()');\n      this.close_requested = true;\n      this.recover_attempts = 0;\n      this.status = C.STATUS_DISCONNECTED; // Clear recovery_timer.\n\n      if (this.recovery_timer !== null) {\n        clearTimeout(this.recovery_timer);\n        this.recovery_timer = null;\n      } // Unbind socket event callbacks.\n\n\n      this.socket.onconnect = function () {};\n\n      this.socket.ondisconnect = function () {};\n\n      this.socket.ondata = function () {};\n\n      this.socket.disconnect();\n      this.ondisconnect({\n        socket: this.socket,\n        error: false\n      });\n    }\n  }, {\n    key: \"send\",\n    value: function send(data) {\n      logger.debug('send()');\n\n      if (!this.isConnected()) {\n        logger.warn('unable to send message, transport is not connected');\n        return false;\n      }\n\n      var message = data.toString();\n      logger.debug(\"sending message:\\n\\n\".concat(message, \"\\n\"));\n      return this.socket.send(message);\n    }\n  }, {\n    key: \"isConnected\",\n    value: function isConnected() {\n      return this.status === C.STATUS_CONNECTED;\n    }\n  }, {\n    key: \"isConnecting\",\n    value: function isConnecting() {\n      return this.status === C.STATUS_CONNECTING;\n    }\n    /**\n     * Private API.\n     */\n\n  }, {\n    key: \"_reconnect\",\n    value: function _reconnect() {\n      var _this = this;\n\n      this.recover_attempts += 1;\n      var k = Math.floor(Math.random() * Math.pow(2, this.recover_attempts) + 1);\n\n      if (k < this.recovery_options.min_interval) {\n        k = this.recovery_options.min_interval;\n      } else if (k > this.recovery_options.max_interval) {\n        k = this.recovery_options.max_interval;\n      }\n\n      logger.debug(\"reconnection attempt: \".concat(this.recover_attempts, \". next connection attempt in \").concat(k, \" seconds\"));\n      this.recovery_timer = setTimeout(function () {\n        if (!_this.close_requested && !(_this.isConnected() || _this.isConnecting())) {\n          // Get the next available socket with higher weight.\n          _this._getSocket(); // Connect the socket.\n\n\n          _this.connect();\n        }\n      }, k * 1000);\n    }\n    /**\n     * get the next available socket with higher weight\n     */\n\n  }, {\n    key: \"_getSocket\",\n    value: function _getSocket() {\n      var candidates = [];\n      this.sockets.forEach(function (socket) {\n        if (socket.status === C.SOCKET_STATUS_ERROR) {\n          return; // continue the array iteration\n        } else if (candidates.length === 0) {\n          candidates.push(socket);\n        } else if (socket.weight > candidates[0].weight) {\n          candidates = [socket];\n        } else if (socket.weight === candidates[0].weight) {\n          candidates.push(socket);\n        }\n      });\n\n      if (candidates.length === 0) {\n        // All sockets have failed. reset sockets status.\n        this.sockets.forEach(function (socket) {\n          socket.status = C.SOCKET_STATUS_READY;\n        }); // Get next available socket.\n\n        this._getSocket();\n\n        return;\n      }\n\n      var idx = Math.floor(Math.random() * candidates.length);\n      this.socket = candidates[idx].socket;\n    }\n    /**\n     * Socket Event Handlers\n     */\n\n  }, {\n    key: \"_onConnect\",\n    value: function _onConnect() {\n      this.recover_attempts = 0;\n      this.status = C.STATUS_CONNECTED; // Clear recovery_timer.\n\n      if (this.recovery_timer !== null) {\n        clearTimeout(this.recovery_timer);\n        this.recovery_timer = null;\n      }\n\n      this.onconnect({\n        socket: this\n      });\n    }\n  }, {\n    key: \"_onDisconnect\",\n    value: function _onDisconnect(error, code, reason) {\n      this.status = C.STATUS_DISCONNECTED;\n      this.ondisconnect({\n        socket: this.socket,\n        error: error,\n        code: code,\n        reason: reason\n      });\n\n      if (this.close_requested) {\n        return;\n      } // Update socket status.\n      else {\n          this.sockets.forEach(function (socket) {\n            if (this.socket === socket.socket) {\n              socket.status = C.SOCKET_STATUS_ERROR;\n            }\n          }, this);\n        }\n\n      this._reconnect(error);\n    }\n  }, {\n    key: \"_onData\",\n    value: function _onData(data) {\n      // CRLF Keep Alive response from server. Ignore it.\n      if (data === '\\r\\n') {\n        logger.debug('received message with CRLF Keep Alive response');\n        return;\n      } // Binary message.\n      else if (typeof data !== 'string') {\n          try {\n            if (this.textDecoder) data = this.textDecoder.decode(data);else data = String.fromCharCode.apply(null, new Uint8Array(data));\n          } catch (evt) {\n            logger.debug('received binary message failed to be converted into string,' + ' message discarded');\n            return;\n          }\n\n          logger.debug(\"received binary message:\\n\\n\".concat(data, \"\\n\"));\n        } // Text message.\n        else {\n            logger.debug(\"received text message:\\n\\n\".concat(data, \"\\n\"));\n          }\n\n      this.ondata({\n        transport: this,\n        message: data\n      });\n    }\n  }, {\n    key: \"via_transport\",\n    get: function get() {\n      return this.socket.via_transport;\n    }\n  }, {\n    key: \"url\",\n    get: function get() {\n      return this.socket.url;\n    }\n  }, {\n    key: \"sip_uri\",\n    get: function get() {\n      return this.socket.sip_uri;\n    }\n  }]);\n\n  return Transport;\n}();","map":{"version":3,"sources":["/Users/tuphan/Desktop/gcallstest/client/node_modules/jssip/lib-es5/Transport.js"],"names":["_classCallCheck","instance","Constructor","TypeError","_defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","_createClass","protoProps","staticProps","prototype","Logger","require","Socket","JsSIP_C","logger","C","STATUS_CONNECTED","STATUS_CONNECTING","STATUS_DISCONNECTED","SOCKET_STATUS_READY","SOCKET_STATUS_ERROR","recovery_options","min_interval","CONNECTION_RECOVERY_MIN_INTERVAL","max_interval","CONNECTION_RECOVERY_MAX_INTERVAL","module","exports","Transport","sockets","arguments","undefined","debug","status","socket","recover_attempts","recovery_timer","close_requested","textDecoder","TextDecoder","error","warn","concat","Array","forEach","isSocket","weight","Number","push","_getSocket","value","connect","isConnected","isConnecting","onconnecting","attempts","onconnect","_onConnect","bind","ondisconnect","_onDisconnect","ondata","_onData","disconnect","clearTimeout","send","data","message","toString","_reconnect","_this","k","Math","floor","random","pow","setTimeout","candidates","idx","code","reason","decode","String","fromCharCode","apply","Uint8Array","evt","transport","get","via_transport","url","sip_uri"],"mappings":"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","sourcesContent":["\"use strict\";\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar Logger = require('./Logger');\n\nvar Socket = require('./Socket');\n\nvar JsSIP_C = require('./Constants');\n\nvar logger = new Logger('Transport');\n/**\n * Constants\n */\n\nvar C = {\n  // Transport status.\n  STATUS_CONNECTED: 0,\n  STATUS_CONNECTING: 1,\n  STATUS_DISCONNECTED: 2,\n  // Socket status.\n  SOCKET_STATUS_READY: 0,\n  SOCKET_STATUS_ERROR: 1,\n  // Recovery options.\n  recovery_options: {\n    // minimum interval in seconds between recover attempts.\n    min_interval: JsSIP_C.CONNECTION_RECOVERY_MIN_INTERVAL,\n    // maximum interval in seconds between recover attempts.\n    max_interval: JsSIP_C.CONNECTION_RECOVERY_MAX_INTERVAL\n  }\n};\n/*\n * Manages one or multiple JsSIP.Socket instances.\n * Is reponsible for transport recovery logic among all socket instances.\n *\n * @socket JsSIP::Socket instance\n */\n\nmodule.exports = /*#__PURE__*/function () {\n  function Transport(sockets) {\n    var recovery_options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : C.recovery_options;\n\n    _classCallCheck(this, Transport);\n\n    logger.debug('new()');\n    this.status = C.STATUS_DISCONNECTED; // Current socket.\n\n    this.socket = null; // Socket collection.\n\n    this.sockets = [];\n    this.recovery_options = recovery_options;\n    this.recover_attempts = 0;\n    this.recovery_timer = null;\n    this.close_requested = false; // It seems that TextDecoder is not available in some versions of React-Native.\n    // See https://github.com/versatica/JsSIP/issues/695\n\n    try {\n      this.textDecoder = new TextDecoder('utf8');\n    } catch (error) {\n      logger.warn(\"cannot use TextDecoder: \".concat(error));\n    }\n\n    if (typeof sockets === 'undefined') {\n      throw new TypeError('Invalid argument.' + ' undefined \\'sockets\\' argument');\n    }\n\n    if (!(sockets instanceof Array)) {\n      sockets = [sockets];\n    }\n\n    sockets.forEach(function (socket) {\n      if (!Socket.isSocket(socket.socket)) {\n        throw new TypeError('Invalid argument.' + ' invalid \\'JsSIP.Socket\\' instance');\n      }\n\n      if (socket.weight && !Number(socket.weight)) {\n        throw new TypeError('Invalid argument.' + ' \\'weight\\' attribute is not a number');\n      }\n\n      this.sockets.push({\n        socket: socket.socket,\n        weight: socket.weight || 0,\n        status: C.SOCKET_STATUS_READY\n      });\n    }, this); // Get the socket with higher weight.\n\n    this._getSocket();\n  }\n  /**\n   * Instance Methods\n   */\n\n\n  _createClass(Transport, [{\n    key: \"connect\",\n    value: function connect() {\n      logger.debug('connect()');\n\n      if (this.isConnected()) {\n        logger.debug('Transport is already connected');\n        return;\n      } else if (this.isConnecting()) {\n        logger.debug('Transport is connecting');\n        return;\n      }\n\n      this.close_requested = false;\n      this.status = C.STATUS_CONNECTING;\n      this.onconnecting({\n        socket: this.socket,\n        attempts: this.recover_attempts\n      });\n\n      if (!this.close_requested) {\n        // Bind socket event callbacks.\n        this.socket.onconnect = this._onConnect.bind(this);\n        this.socket.ondisconnect = this._onDisconnect.bind(this);\n        this.socket.ondata = this._onData.bind(this);\n        this.socket.connect();\n      }\n\n      return;\n    }\n  }, {\n    key: \"disconnect\",\n    value: function disconnect() {\n      logger.debug('close()');\n      this.close_requested = true;\n      this.recover_attempts = 0;\n      this.status = C.STATUS_DISCONNECTED; // Clear recovery_timer.\n\n      if (this.recovery_timer !== null) {\n        clearTimeout(this.recovery_timer);\n        this.recovery_timer = null;\n      } // Unbind socket event callbacks.\n\n\n      this.socket.onconnect = function () {};\n\n      this.socket.ondisconnect = function () {};\n\n      this.socket.ondata = function () {};\n\n      this.socket.disconnect();\n      this.ondisconnect({\n        socket: this.socket,\n        error: false\n      });\n    }\n  }, {\n    key: \"send\",\n    value: function send(data) {\n      logger.debug('send()');\n\n      if (!this.isConnected()) {\n        logger.warn('unable to send message, transport is not connected');\n        return false;\n      }\n\n      var message = data.toString();\n      logger.debug(\"sending message:\\n\\n\".concat(message, \"\\n\"));\n      return this.socket.send(message);\n    }\n  }, {\n    key: \"isConnected\",\n    value: function isConnected() {\n      return this.status === C.STATUS_CONNECTED;\n    }\n  }, {\n    key: \"isConnecting\",\n    value: function isConnecting() {\n      return this.status === C.STATUS_CONNECTING;\n    }\n    /**\n     * Private API.\n     */\n\n  }, {\n    key: \"_reconnect\",\n    value: function _reconnect() {\n      var _this = this;\n\n      this.recover_attempts += 1;\n      var k = Math.floor(Math.random() * Math.pow(2, this.recover_attempts) + 1);\n\n      if (k < this.recovery_options.min_interval) {\n        k = this.recovery_options.min_interval;\n      } else if (k > this.recovery_options.max_interval) {\n        k = this.recovery_options.max_interval;\n      }\n\n      logger.debug(\"reconnection attempt: \".concat(this.recover_attempts, \". next connection attempt in \").concat(k, \" seconds\"));\n      this.recovery_timer = setTimeout(function () {\n        if (!_this.close_requested && !(_this.isConnected() || _this.isConnecting())) {\n          // Get the next available socket with higher weight.\n          _this._getSocket(); // Connect the socket.\n\n\n          _this.connect();\n        }\n      }, k * 1000);\n    }\n    /**\n     * get the next available socket with higher weight\n     */\n\n  }, {\n    key: \"_getSocket\",\n    value: function _getSocket() {\n      var candidates = [];\n      this.sockets.forEach(function (socket) {\n        if (socket.status === C.SOCKET_STATUS_ERROR) {\n          return; // continue the array iteration\n        } else if (candidates.length === 0) {\n          candidates.push(socket);\n        } else if (socket.weight > candidates[0].weight) {\n          candidates = [socket];\n        } else if (socket.weight === candidates[0].weight) {\n          candidates.push(socket);\n        }\n      });\n\n      if (candidates.length === 0) {\n        // All sockets have failed. reset sockets status.\n        this.sockets.forEach(function (socket) {\n          socket.status = C.SOCKET_STATUS_READY;\n        }); // Get next available socket.\n\n        this._getSocket();\n\n        return;\n      }\n\n      var idx = Math.floor(Math.random() * candidates.length);\n      this.socket = candidates[idx].socket;\n    }\n    /**\n     * Socket Event Handlers\n     */\n\n  }, {\n    key: \"_onConnect\",\n    value: function _onConnect() {\n      this.recover_attempts = 0;\n      this.status = C.STATUS_CONNECTED; // Clear recovery_timer.\n\n      if (this.recovery_timer !== null) {\n        clearTimeout(this.recovery_timer);\n        this.recovery_timer = null;\n      }\n\n      this.onconnect({\n        socket: this\n      });\n    }\n  }, {\n    key: \"_onDisconnect\",\n    value: function _onDisconnect(error, code, reason) {\n      this.status = C.STATUS_DISCONNECTED;\n      this.ondisconnect({\n        socket: this.socket,\n        error: error,\n        code: code,\n        reason: reason\n      });\n\n      if (this.close_requested) {\n        return;\n      } // Update socket status.\n      else {\n          this.sockets.forEach(function (socket) {\n            if (this.socket === socket.socket) {\n              socket.status = C.SOCKET_STATUS_ERROR;\n            }\n          }, this);\n        }\n\n      this._reconnect(error);\n    }\n  }, {\n    key: \"_onData\",\n    value: function _onData(data) {\n      // CRLF Keep Alive response from server. Ignore it.\n      if (data === '\\r\\n') {\n        logger.debug('received message with CRLF Keep Alive response');\n        return;\n      } // Binary message.\n      else if (typeof data !== 'string') {\n          try {\n            if (this.textDecoder) data = this.textDecoder.decode(data);else data = String.fromCharCode.apply(null, new Uint8Array(data));\n          } catch (evt) {\n            logger.debug('received binary message failed to be converted into string,' + ' message discarded');\n            return;\n          }\n\n          logger.debug(\"received binary message:\\n\\n\".concat(data, \"\\n\"));\n        } // Text message.\n        else {\n            logger.debug(\"received text message:\\n\\n\".concat(data, \"\\n\"));\n          }\n\n      this.ondata({\n        transport: this,\n        message: data\n      });\n    }\n  }, {\n    key: \"via_transport\",\n    get: function get() {\n      return this.socket.via_transport;\n    }\n  }, {\n    key: \"url\",\n    get: function get() {\n      return this.socket.url;\n    }\n  }, {\n    key: \"sip_uri\",\n    get: function get() {\n      return this.socket.sip_uri;\n    }\n  }]);\n\n  return Transport;\n}();"]},"metadata":{},"sourceType":"script"}